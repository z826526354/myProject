## 继承模式，命名空间，对象枚举

### 继承模式

- 传统模式——> 原型链（prototype）

  过多的继承了没用的属性

- 借用构造函数（call / apply）

  不能继承借用构造函数的原型

  每次构造函数夺多走一个函数

- 共享原型（）

  不能随意改动自己的原型

  ```js
  Father.prototype.lastname = "huang";
  function Father() {}
  function Son() {}
  Son.prototype = Father.prototype
  var son = new Son();
  console.log(son.lastname); // huang
  // extend inherit（继承）
  
  // 封装继承方法
  Father.prototype.lastname = "huang";
  function Father() {}
  function Son() {}
  function inherit(Target, Origin) {
      Target.prototype = Origin.prototype;
  }
  inherit(Son, Father);
  // 这样不好，因为如果要给son单独添加一个属性的时候，将会同时给Father加上属性
  var son = new Son();
  // 于是就出现了圣杯模式
  ```

  

- 圣杯模式（加一个中介）

  ```js
  Father.prototype.lastname = "huang";
  function Father() {}
  function Son() {}
  function inherit(Target, Origin) {
      function F() {};
      F.prototype = Origin.prototype;
      Target.prototype = new F();
      Target.prototype.constuctor = Target;// 让constuctor指向目标对象
      Target.prototype.uber = Origin.prototype; // 找到自己的超级父级，最终继承自谁
  }
  inherit(Son, Father);
  var son = new Son();
  var father = new Father();
  Son.prototype.sex = "male";
  console.log(son.sex, father.ser); // male undefined
  
  /*
  我们还可以在丰满一下
  son.__proto__ --> new F().__proto__ --> Father.prototype
  */
  
  // 雅虎YUI3库的圣杯模式
  var inherit = (function () {
      var F = function () {};
      return function (Target, Origin) {
          F.prototype = Origin.prototype;
      	Target.prototype = new F();
      	Target.prototype.constuctor = Target;
      	Target.prototype.uber = Origin.prototype;
      }
  }())
  // 闭包的第三作用：函数封装私有化
  /*
  F 被储存在return的函数的执行期上下文里面，被有私有化了（隐藏了），
  因为F是过度的函数，所以这个私有化是很好的
  */
  ```

  

### 命名空间

- 管理变量，防止污染全局，适用于模块化开发

